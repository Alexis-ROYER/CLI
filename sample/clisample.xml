<?xml version="1.0" encoding="ISO-8859-1"?>

<!--
    Copyright 2006 Alexis Royer

    This file is part of the CLI library.

    The CLI library is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2.1 of the License, or
    (at your option) any later version.

    Foobar is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with Foobar; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-->

<!-- Define the root element. Obviously, it is named 'cli'. -->
<!-- Give it a name through the '@name' attribute. -->
<cli name="sample-cli" cpp="PCLI_SampleCli" xmlns="http://alexis.royer.free.fr/cli/1.0/">
	<!-- 'cpp' attributes and elements allows you to command the target generation. -->
	<!-- The '@cpp' attribute above declares a CcliCli object pointer. This way, you can reference this CLI from the outside, especially for CcliShell::RunConsole() or CcliShell::RunTelnet(). -->

	<!--
	A CLI is composed of menus.
	Each menu defines a set of command lines.
	Command lines are sequences of keywords and parameters terminated by a return carriage.
	The syntax is defined through a tree of words and parameters.
	-->

	<!-- 'keyword' elements define keywords. -->
	<keyword string="print">
		<!-- For each element, you can give help as done below. -->
		<help lang="en">Print stuff</help>

		<!-- Keywords can be followed by other keywords. -->
		<keyword string="author"><help lang="en">Print out the name of the author of this sample cli.</help>
			<!-- At the end of each branch there should normally be an 'endl' (end of line) element. -->
			<endl>
				<!-- 'cpp' elements directly generate C++ code. -->
				<!-- 'endl' elements typically own 'cpp' elements. -->
				<cpp><out/> &lt;&lt; "Alexis Royer" &lt;&lt; CLI_ENDL;</cpp>
				<!-- 'out' element references the output stream. It is used as std::cout through the << operator. -->
			</endl>
		</keyword>
		<keyword string="word"><help lang="en">Print out a single word</help>
			<!-- Parameters can also be defined. Parameters are typed through the '@type' attribute. Give it an ID through the '@id' attribute. -->
			<param id="the-word" type="string">
				<!-- 'value-of' elements can then be used to reference the parameters. Only ancestor parameters can be referenced. -->
				<endl><cpp><out/> &lt;&lt; <value-of param="the-word"/> &lt;&lt; CLI_ENDL;</cpp></endl>
			</param>
		</keyword>
		<keyword string="words"><help lang="en">Print out several words</help>
			<!-- Sometimes, you might need to break out the tree structure. You can use 'tag' elements and references to them. Tags and tag references can be compared to labels and gotos in C. -->
			<cpp>std::vector&lt;std::string&gt; vstr_Words;</cpp>
			<tag id="words">
				<!-- Notice that tags sub-elements are directly accessible by the parent nodes. On the other hand, when the execution comes back to this point, only the tag sub-elements are accessible, not the parent node ones. -->
				<param id="a-word" type="string">
					<cpp>vstr_Words.push_back(<value-of param="a-word"/>);</cpp>
					<tag ref="words"/>
				</param>
				<endl>
					<cpp>for (int i=0; i&lt;vstr_Words.size(); i++) {</cpp>
					<cpp>    if (i>0) <out/> &lt;&lt; " ";</cpp>
					<cpp>    <out/> &lt;&lt; vstr_Words[i];</cpp>
					<cpp>}</cpp>
					<cpp><out/> &lt;&lt; CLI_ENDL;</cpp>
				</endl>
			</tag>
		</keyword>
	</keyword>

	<!-- Now we deal about menus --> 
	<keyword string="enter"><help lang="en">Enter a menu</help>
		<keyword string="sample-menu"><help lang="en">Enter sample-menu</help>
			<endl>
				<cpp><out/> &lt;&lt; "Entering sample-menu" &lt;&lt; CLI_ENDL;</cpp>
				<!-- Menu references can be found in 'endl' elements. -->
				<menu ref="sample-menu"/>
			</endl>
		</keyword>
	</keyword>
	<!-- Here is the menu definition. The menu should be named through the '@name' attribute. -->
	<menu name="sample-menu"><help lang="en">Sample menu</help>
		<!-- The menu defines its own syntax tree. -->
		<keyword string="hello"><help lang="en">Hello world</help>
			<endl><cpp><out/> &lt;&lt; "Hello world" &lt;&lt; CLI_ENDL;</cpp></endl>
		</keyword>
	</menu>

	<!-- 'cpp' child elements of the CLI can receive specific options... -->
	<!-- 'cpp' elements with the 'include' option generate code right after CLI includes. -->
	<cpp option="include">///////////////////////////////</cpp>
	<cpp option="include">// User define code ('include')</cpp>
	<cpp option="include">#include &lt;string&gt;</cpp>

	<!-- 'cpp' elements with the 'menu-decl' option generate code right after CLI declarations. -->
	<cpp option="menu-decl">/////////////////////////////////</cpp>
	<cpp option="menu-decl">// User define code ('menu-decl')</cpp>

	<!-- 'cpp' elements with the 'nodes' option generate code right after CLI node definition. -->
	<cpp option="nodes">/////////////////////////////</cpp>
	<cpp option="nodes">// User define code ('nodes')</cpp>

	<!-- 'cpp' elements with the 'menu-impl' option generate code right after CLI menus implementation. This example uses this section to define the main function. CcliShell::RunConsole() is used. -->
	<cpp option="menu-impl">/////////////////////////////////</cpp>
	<cpp option="menu-impl">// User define code ('menu-impl')</cpp>

	<cpp option="menu-impl">int main(void) {</cpp>
	<cpp option="menu-impl">    CcliShell cli_Shell(*PCLI_SampleCli);</cpp>
	<cpp option="menu-impl">    cli_Shell.RunConsole();</cpp>
	<cpp option="menu-impl">    return 0;</cpp>
	<cpp option="menu-impl">}</cpp>

</cli>

